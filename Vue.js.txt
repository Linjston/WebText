Vue.js 

、、、目录：///1简单vue实例
         ///2.模式
         ///3.创建全局组件
         ///4.组件传值
         ///5.Vue实例的生命周期钩子
         ///6.Vue的模板语法
         ///7.计算属性，方法和侦听器
         ///8.Vue中的样式绑定
         ///9.Vue中的条件渲染
         ///10.列表渲染
         ///11.组件细节
         ///12.组件参数校验与非props特性
         ///13.给组件绑定原生事件
         ///14.Vue中的作用域插槽
         ///15.动态组件与v-once指令
         Vue中的动画特效：
         ///16.Vue中的CSS动画原理（过渡）
         ///17.在Vue中使用Animation.css库
         ///18.在vue中同时使用过渡和动画
         ///19.Vue中的js动画与Velocity.js的结合
         ///20.Vue中多个元素或组件的过渡
         ///21.Vue的列表过渡
         ///22.Vue中的动画封装
         ///23.单文件组件与Vue中的路由
         ///24.多页应用和单页应用


         ////指令
         ////配置
///1简单vue实例：
head标签中引进vue.js库
 <body>
  <div id="app">{{content}}</div>

 <script>
   var app = new Vue({
      el:'#app', //指的是Vue实例的范围是id为app的dom结点，包括其子孙
      data:{
         content:'hello world'
      }
   })

   setTimeout(()=>{
   	 app.$data.content = 'shuaitong';
   }, 2000)
 </script>  
 </body>

///2.模式
MVP模式
  view(视图层，DOM结点) ->			        <- Model
      		 		   <- Presenter(控制器)  ->

  视图层发出请求给控制器，控制器可以通过ajax去获取数据，然后控制器对DOM进行操作，更新view层

MVVM模式:
1.Vue(VM层)监听Model层数据的变化，然后去改变View层；
2.Vue(VM层)监听View层事件触发，然后通过VM层的代码改变Model层的数据，然后再执行1.

所以我们主要写的是View层和Modle层。
             ViewModel
        ->  DOM Listeners  ->  
   View                       Model  
  	|	<-  Data Bindings  <-	|
    |			  |				|
   DOM  		 Vue 		  Plain js Object


///3.创建全局组件
eg.E:\VScode-vue\todolist.html

Vue.component("TodoItem",{
  props:[content], 
	template:"<li>todo  item</li>"
})
除了模板，其他跟正常组件一样。


///4.组件传值
i.父子组件传值：
eg.E:\VScode-vue\todolist.html
父传子：
  <div id="root">
      <ul>
  //1.root父组件传值给todo-item子组件，通过在子组件上绑定一个变量，例如绑定content， 将 item的值绑定给content
         <todo-item v-bind:content="item" 
                    v-bind:index="index"
                    v-for="(item,index) in list">
         </todo-item>
      </ul>
    </div>


    var TodoItem={
   //2.子组件里面通过props来接收父组件绑定的变量
        props:['content','index'], 
          template:"<li>{{content}}</li>",
      };

    var app = new Vue({
        el:'root',
        data:{
           list:['af',"sdf"]
        },
        components:{
           TodoItem:TodoItem 
           //使用组件时不能用这个名字的格式，要使用todo-item
        }
    })

单向数据流：父传子的数据可以随意修改，但是子组件不能修改接收的数据。


子传父：
  1.在父组件中的子组件绑定一个自定义事件，并监听这个事件；
  2.在子组件中触发这个事件，并将值传递给这个事件；
  3.为父组件中这个自定义事件写一个触发函数，其参数为子组件传递给事件的值。
body:
  <div id="root">
      <ul>
         <todo-item v-bind:content="item" 
                v-bind:index="index"
                 v-for="(item,index) in list"
                 @delete="handleItemDelete">
    //上面就是第1步和第3步，创建了自定义事件和触发函数
         </todo-item>
      </ul>
    </div>

script:
  var TodoItem={
      props:['content','index'], 
        template:"<li @click='handleItemClick'>{{content}}</li>",
        methods:{
          handleItemClick:function(){
            this.$emit("delete",this.index)
          //此处为第2步，触发自定义事件和传值
          }
        }

    };

    var app = new Vue({
      el:'#root',
      data:{
        todoValue:'',
        list:[]
      },
      methods:{
       handleBtnClick:function(){
        this.list.push(this.todoValue);
        this.todoValue = '';
        },
        handleItemDelete:function(index){
            this.list.splice(index,1)
        }
        },
        components:{
          TodoItem:TodoItem
        }  //注册组件
    })

ii.非父子组件间的传值：
 方式一：VueX

 方式二：Bus/总线/发布订阅模式/观察中模式
 eg.E:\VScode-vue\N-pass value.html
   1.通过在Vue的原型中加入属性，这个属性是一个vue实例的引用：Vue.prototype.bus = new Vue()
   这样每个vue实例都有这个属性；

   2.在要接收数据的非父子组件中使用生命周期函数监听这个bus实例的自定义事件，还有设置回调函数，参数为传递的值：
   mounted:function(){
        var this_ = this;
        this.bus.$on('change',function(msg){
            this_.selfContent = msg;
            //这里面的this指的是bus这个实例，所以要保存外面的this
        })
    }

    3.要发送数据的非父子组件，通过触发bus实例中的自定义事件，来传值：
    methods:{
        handleClick:function(){
          this.bus.$emit('change',this.selfContent)
        }
      }

2个非父子组件A和B，
A通过触发bus实例中的change事件，传递数据出去；
B通过监听change事件，获得数据。
同理，
B通过触发bus实例中的change2事件，传递数据出去；
A通过监听change2事件，获得数据。




///5.Vue实例的生命周期钩子
生命周期函数就是vue实例在某一个时间点会自动执行的函数。

  i.new Vue() 新建Vue实例 
  -->ii.初始化（事件&生命周期）    beforeCreate() 
  -->iii.初始化（注入&校验）       created()
  -->iv.是否指定el -->否 -->当调用vm.&mount(el)函数时转到 v
                  -->是  转到 v
  -->v.是否指定template  -->是 将template编译到render函数中（渲染）
                        -->否 将el外部的HTML作为template编译（渲染）  beforeMount()
  -->vi.创建vm.$el并替换 el(挂载el)    mounted()
  -->vii.挂载完毕   --> 当data被修改    beforeUpdata()
                                   --> 虚拟DOM重新渲染并应用更新    updated() 
  -->viii.当调用vm.$destory()      beforeDestory()
  -->ix.解除绑定 销毁子组件以及时间监听器    
  -->x.销毁完毕                     destroyed()   
  

  beforeCreate:
    实例初始化之后，this指向创建的实例

    数据观测（data observer）和event/watcher配置尚未完成
    不能访问到methods、data、computed、watch上的方法和数据


  created:
    实例创建完成
    并已经完成以下配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调
    此时可以调用methods中定义的方法，修改data的数据，并且可触发响应式变化、computed值重新计算，watch到变更等

    还未挂载到DOM，不能访问到$el属性，$ref属性内容为空数组

    【这个生命周期阶段比较常用，比如ajax请求获取初始化数据对实例进行初始化预处理等操作；
     但要注意在结合vue-router使用时，进入created生命周期阶段后是无法对挂载实例进行拦截的，此时实例已经创建完成；
     故如果需要某些数据获取完成情况才允许进入页面的场景，建议在路由钩子beforeRouteEnter中实现
    】

  beforeMount：
    在挂载开始之前被调用
    注意：从vue生命周期图可以看出
    当new Vue({...})的配置中没有el属性时，生命周期暂停，等待vm.$mount(el)调用时才继续

    beforeMount之前，会找到对应的template，并编译成render函数
    template查找的优先级顺序:
    ** template参数 > el 外部HTML**
    如果指定了render函数，则直接采用render函数，即忽略template参数和el外部HTML


  mounted：
    el被新创建的$el替换 ---- 怎么理解？
    这个可以理解为挂载前为实例寻找了一个暂时容身之处el，编译完成($el创建完成)后替换这个容身之处完成实例的挂载；
    实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问；
    在这个阶段改变data上的值，相关的computed属性可以立刻更新；但需要进入到下一次DOM更新，才能看到DOM上数据更新；


  beforeUpdate：
    这里的更新对象是模板，即需要虚拟 DOM 重新渲染和打补丁，beforeUpdate发生在以上两个流程之前，此时新的虚拟DOM已经生成；
    【如果发生变更的数据在模板中并没有使用（包括直接和间接，间接：比如某个依赖该数据的计算属性在模板中使用了），则不会触发更新流程！！！】

    eg.应该避免在这个钩子函数中操作数据
      beforeUpdate() {
        console.log(document.getElementById('testa').innerHTML)
        // this.c = 1;   //  this.c没有在模板中使用，变更不会引起重渲染流程
        // this.a = 3;  //  会再次进入一次重渲染流程，第二次进入时发现a仍是3，值没有变更，不会再次重渲染
        // this.a ++;   //  会引起死循环，每次进入重渲染流程时，a的值都会变更
      }




  updated:
    由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。
    当这个钩子被调用时，组件 DOM 已经更新，可以执行依赖于 DOM 的操作
    同样，应该避免在这个钩子函数中操作数据


  beforeDestroy
    实例销毁之前调用。在这一步，实例仍然完全可用，this仍能获取到实例
    一般在这一步中进行：销毁定时器、解绑全局事件、销毁插件对象等操作

  destroyed
    Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁

///6.Vue的模板语法
三者里面都可以写js语法：
Vue 实例中data:{val:"<h1>shuaitong</h1>"}
i.插值表达式 eg.{{val}}   //<h1>shuaitong</h1>
ii.v-text  eg.<div v-text="val + 'zuishuai'"></div> 
   //<h1>shuaitong</h1>zuishuai
iii.v-html  eg.<div v-html='val'></div>
    //shuaitong (使用h1标签)


///7.计算属性，方法和侦听器
eg.E:\VScode-vue\computed.html
i.计算属性：computed 
//计算属性 会进行缓存，当里面使用的数据没有改变过，不会重新计算，使用缓存的结果；
当使用的数据改变了，才重新计算。
eg.computed:{
      fullName:function(){
        console.log("计算了一次");
        return this.firstName + " " + this.lastName;
      }
    }
 调用2次{{fullName}}，但只打印1次“计算了一次”

 ii.方法：methods
 eg.data:{
      firstName:'shuaitong',
      lastName:'zuishuai',
      age:22
    }
    methods:{
      fullName:function(){
        console.log("计算了一次");
        return this.firstName + " " + this.lastName;
      }
    }

    {{fullName()}} ,{{age}},{{fullName()}}
 //方法 没有缓冲机制，每次使用都要重新渲染一次，
   所以会打印2次 “计算了一次”；
   而且只要数据发生变化，所有都要重新渲染
   假如改变age的值，fullName也会重新渲染，会再打印一次“计算了一次”


iii.监听器 watch
监听某个属性数据的变化，执行对应的执行函数.
eg.
data:{
      firstName:'shuaitong',
      lastName:'zuishuai',
      fullName:"hahaha",
      age:22
    },

watch:{
        firstName:function(){
          console.log("计算了一次");
          this.fullName=this.firstName + " " + this.lastName;
        },//监听firstName,变化执行firstName
        lastName:function(){
          console.log("计算了一次");
          this.fullName=this.firstName + " " + this.lastName;
        }//监听lastName,变化执行firstName
      }

  {{fullName}} ,{{age}},{{fullName}}
 
 //一开始fullName存在，而且firstName和lastName没变化
 所以没有发生改变；
 当你改变firstName或lastName其中一个，就会执行对应的函数



iv.计算属性的getter和setter
eg.
computed:{
    fullName:{
        get：function(){
          return this.firstName + " " + this.lastName;
        },//当获取该属性时，使用get方法
        set:function(val){
          var arr = val.split(" ");
          this.firstName = arr[0];
          this.lastName = arr[1];
        }//当设置属性时，使用set方法，参数为设置值
    }
} //计算属性依赖的值改变时，引起计算属性的重新计算




///8.Vue中的样式绑定
eg.E:\VScode-vue\style-bind.html
i.class的对象绑定
给DOM结点绑定样式【 :class="{类名：布尔值}" 】
通过控制布尔值控制类的使用或不使用
eg.
<div @click="handleDivClick"
       :class="{activated:isActivated}"
    >
      shuaitong
    </div>
通过控制isActivated的真假转换，从而控制activated类的出现或者消失：
this.isActivated = !this.isActivated;


ii.使用绑定的变量值当作绑定的类
【 ：class = "[变量1，变量2,....]" 】
eg.
<div id="app">
    <div @click="handleDivClick"
       :class="[activated]"
    >
      shuaitong
    </div>
通过改变vue实例中 activated的字符串值，来决定类名，通过绑定点击事件来修改activated的字符串值：
this.activated = this.activated === "activated2"?"":"activated2";


iii.使用【：style="[对象1,对象2]"】,样式写在对象中
eg.
<div :style = "[styleObj,{fontSize:'50px'}]"
       @click="handleDivClick"
    >
      shuaitong
    </div>

data:{  
        styleObj:{},
        styleObj1:{
          background:"pink"
        }
      }
注意的点，像font-size这种格式的css属性要写成小驼峰格式fontSize；可以像使用this.styleObj.background = "red"，去改变样式;
也可以先给空对象，然后通过判断对象是否为空，赋值：
第一种：this.styleObj = Object.keys(this.styleObj).length == 0 ? this.styleObj1:{};
第二种：(JSON.stringify(this.styleObj) == "{}");
第三种：
        for in 循环判断
        var obj = {};
        var b = function() {
        for(var key in obj) {
        return false;
        }
        return true;
        }
        alert(b());//true




///9.Vue中的条件渲染
eg.E:\VScode-vue\conditional-rendering.html
i.v-if ="show" 和 v-show ="show":
当show为false,
 v-show只是将div的style="display: none;",该div已经渲染了，在DOM树上；
 v-if:该div未渲染，不在DOM树上.

 ii.v-if="show"和 v-else-if和v-else (需要紧贴在一起使用)
【vue.js 2.1.0版本以上可以使用v-else-if】
eg.
   <div v-if="case === 'a'">a</div>
   <div v-else-if="case === 'b'">b</div>
   <div v-else>other</div>

通过判断case的值决定，先判断v-if，再判断v-else-if，最后是v-else 


iii.key值解决复用问题
eg.
<div v-if="show">
      用户名：<input key="username"/>
    </div>
    <div v-else="show">
      e-mail:<input key="e-mail"/>
    </div>
    当切换时，因为俩者组成的DOM元素是一样的，为了提升性能，vue后台会做出处理，当DOM元素相同时，会复用之前的那个DOM，所以用的是同一个input，内容没有改变，但如果加上key值(唯一标识)，key值不一样的，不会复用；key值相同，就会复用。





///10.列表渲染
eg.E:\VScode-vue\list-rendering.html
v-for :(key值每个循环项的唯一标识,只能是数字或者字符串)
数组遍历：
eg.  <div  v-for="(item,index) in list"
        :key="item.id"
    >...</div>

i.不能直接通过数组下标索引来修改数组vm.list[4]=".."，只能用数组的变异方法去修改。//push,pop,unshift,shift,splice,sort,resever
eg.app.list.splice(1,1,{id:"9",text:"..."})

ii.通过改变数组引用也可以更新页面，就是将list指向一个新数组；

iii.使用Vue.set() 【往数组最后面添加元素或者改变已有元素】
eg.
Vue.set(this.list,4,"beijing"); 中间是索引值
eg.或者使用实例
app.$set(this.list,4,"beijing");

对象遍历：
eg.  <div  v-for="(item,key,index) in obj"
        :key="obj.id"
    >...</div>
第一个为值，第二个为键，第三个为索引


i.如果要往对象obj中加值，可以使用改引用的方式，obj指向一个新的对象。
eg.
  obj = {....,address:"...."}

ii.使用Vue.set() 添加属性也能更新页面
eg.
Vue.set(this.obj,"address","beijing")

也可以用实例的$set():
eg.
app.$set(this.obj,"address","beijing")


模板占位符（不会被渲染到页面上):
eg.
<template  v-for="(item,index) of list"
            :key="item.id"
    >
      <div>{{index}}</div>
      <span>{{item.text}}</span>
    </template>

 模板占位符：template 不会被渲染出来，比用div好




 ///11.组件细节
 eg.E:\VScode-vue\bug.html
 i. is="组件名"
 【有些标签下面只能是某些标签，如果不是就会跳出外层标签；
 像table>tbody>tr,如果tbody里面直接用组件代替，会跳出table;】
 eg.
 <table>
      <tbody>
        <row></row>
        <row></row>
        <row></row> 
      </tbody>      
  </table>

最后渲染出来：
<tr><td>row</td></tr>
<tr><td>row</td></tr>
<tr><td>row</td></tr>
<table><tbody></tbody></table>
出现bug.

 假如你想用组件的形式代替tr,可以这么写：
 eg.
<div id="root">
    <table>
      <tbody>
        <tr is="row"></tr>
        <tr is="row"></tr>
        <tr is="row"></tr>
      </tbody>
    </table>
  </div>
  <script type="text/javascript">
    Vue.component("row",{
      template:'<tr><td>row</td></tr>'
    })
    var app = new Vue({
      el:"root"
    })

<tr is="row"></tr>用组件row来代替tr标签。


ii.对于非根组件的子组件，子组件中的data必须是一个函数,根组件的data是一个对象，因为只被掉用一次；
子组件可能被调用多次，通过一个函数返回一个对象，使得每个组件数据有自己独立的存储空间，不会出现多个子组件相互影响。
eg.
Vue.component("row",{
      data:function(){
        return {
          content:"row"
        }
      },
      template:'<tr><td>{{content}}</td></tr>'
    })
    //对于非根组件的子组件，data必须是一个函数

    var app = new Vue({
      el:"#root"，
      data:{....}
    })
    //根组件的data为一个对象


iii.ref
通过在DOM节点设置ref属性，然后在vue实例中通过this.$refs.ref获取DOM结点的引用;
eg.
<div @click="handleClick"
       ref='hello'
    >   
       hello world  
</div>

methods:{
        handleClick:function(){
          console.log(this.$refs.hello.innerHTML)
        }
}

ref也可以作为组件的引用：
eg.E:\VScode-vue\bug.html



///12.组件参数校验与非props特性
i.对父传子的数据进行校验
 eg.
 props:{
        content:{
          type:[String,Number],
          require:true, //该属性一定要传
          default:'默认值',//不传时的默认值
          validator:function(value){
            return (value.length > 5)
          }//校验器  传入的内容长度必须大于5，通过布尔值来表示校验通不通过
        }        
      }

ii.非props特性
props特性：当父组件向子组件使用属性传递数据，而子组件声明了传递过来的属性，父组件和子组件会形成一种映射。
eg.
<div id="root">
    <child :content="str"></child>
</div>

Vue.component("child",{
      props:['content'],
      template:'<div>{{content}}</div>'
});

渲染出来后，<div>sss</div>
渲染出来的DOM是没有显示父组件传给子组件的属性



非props特性是子组件没有声明传过来的属性。
渲染出来是会在组件最外层DOM出现该属性，而且子组件没法使用该属性。
eg.
<div id="root">
    <child :content="str"></child>
</div>

Vue.component("child",{
      template:'<div>hello</div>'
});
而且渲染出来后：<div content="sss">hello</div>



///13.给组件绑定原生事件
i.
在元素上绑定的原生事件，监听的是原生事件：
eg.
<div @click="handleClick">click</div>

在组件上绑定的是自定义事件，监听的是自定义事件：
eg.
<child  @click="handleClick"></child>
//这里的click不是原生的click事件，而是自定义事件，需要用this.$emit('click')触发。

ii.
如何直接在组件监听原生事件，使用修饰符 .native:
eg.
<child  @click.native="handleClick"></child>
//此时监听的click为原生事件




///14.Vue中的作用域插槽\
eg.E:\VScode-vue\Vue-slot.html
i.父组件中的子组件中定义插槽内容
eg.
<div id="root">
    <child>
      <template slot-scope="props">
        <li >{{props.item}}</li>
      </template>
    </child>
  </div>
父组件给子组件传递插槽,插槽内容是<template></template>包裹着；
slot-scope="props"表示子组件传进来的数据放在props中

子组件模板中用<slot></slot>来表示插槽，内容是父组件传过来的<template></template>
同时子组件可以向插槽中传值：
eg.
data:function(){
        return {
          list: [1,2,3,4]
        }
      },
template:`<div>
            <ul>
              <slot
                v-for="item in list"
                :item="item"
              ></slot>
            </ul>
             </div>`
传进插槽的属性item 由父组件的子组件中的template的属性slot-scope="props"接收
2.6版本后废弃slot-scope



iii.具名插槽 v-slot (缩写#,eg.#head)
在一个组件里可以有多个template,但需要给它们命名
eg.
<child>
  <template v-slot:head>
      ....
  </template>
  <template v-slot:main>
      ....
  </template>
</chile>

在组件的模板中通过name属性使用：
  <slot name="head"></slot>
  <slot name="main"></slot>

//一个不带 name 的 <slot>出口会带有隐含的名字“default”。



iv.作用域插槽
绑定在 <slot> 元素上的特性被称为插槽 prop。
给 v-slot 带一个值来定义我们提供的插槽 prop 的名字：

<child>
  <template v-slot:head="slotProps">
      {{slotProps.item}}
  </template>
</chile>

child组件模板：
template:`<div>
            <ul>
              <slot
                name="head"
                v-for="item in list"
                :item="item"
              ></slot>
            </ul>
             </div>`

//如果是只有默认插槽可以缩写：
eg.缩写
<current-user #default="{ user }">
  {{ user.firstName }}
</current-user>

//只要出现多个插槽，请始终为所有的插槽使用完整的基于 <template> 的语法：
<current-user>
  <template v-slot:default="slotProps">
    {{ slotProps.user.firstName }}
  </template>

  <template v-slot:other="otherSlotProps">
    ...
  </template>
</current-user>




///15.动态组件与v-once指令
eg.E:\VScode-vue\Dynamic command&v-once.html
i.通过改变组件名动态显示组件：
<component :is="组件名"></component>

ii.每次切换会销毁前一个组件，创建后一个组件，会很浪费资源,解决方法：v-once

在组件的模板上加上v-once,之后第一次渲染组件会将其保存在内存中;当再次切换到该组件，直接从内存拿出以前的，不用再重新创建，有效解决静态组件的效率：
eg.
Vue.component('child-one',{
      template:`<div v-once>child-one</div>`
    })



///16.Vue中的CSS动画原理(过渡)
eg.E:\VScode-vue\vue-css.html
i.
使用transition标签包裹要动画的元素：
<transition name="fade">
    <div v-if="show">hello world</div>
</transition>

//加name属性，其所有类的前缀为name属性的值；
eg .fade-enter
//没加，默认为v
eg .v-enter

当动画从显示->消失：
1.动画第一帧，有.v-leave 和.v-leave-active 决定样式；
(一般不设置)；
2.动画开始，移除.v-leave，加上.v-leave-to；
3.动画结束，移除.v-leave-to 和 .v-leave-active.

当动画从消失->显示：
1.动画第一帧，有.v-enter 和.v-enter-active 决定样式；
2.动画开始，移除.v-enter，加上.v-enter-to；
3.动画结束，移除.v-enter-to 和 .v-enter-active.

.v-leave-active和.v-enter-active整个动画周期都在

ii.可以自定义类的名字
在transition的属性中添加：
<transition
  enter-active-class="enter"
  leave-active-class="leave"
><div v-show="show">shuaitong</div>
</transition>
则
.v-enter-active 会被  .enter代替；
.v-leave-active 会被  .leave代替。





///17.在Vue中使用Animation.css库
eg.E:\VScode-vue\vue-css-animation.html
i.百度animate.css库，下载到本地，使用link标签引入：
<link rel="stylesheet" type="text/css" href="./animate.css">

ii.使用transition标签更改类名
格式默认为：
enter-active-class="animated 动画效果的类"
leave-active-class="animated 动画效果的类"

eg.
<transition 
    name="fade" 
    enter-active-class="animated swing"
    leave-active-class="animated shake"
    appear
    appera-active-class="animated swing"
    >
    <div v-if="show">hello world</div>
</transition>

//  加上appear 和appear-active-class="animated swing"
可以让元素在第一次出现就使用动画






///18.在vue中同时使用过度和动画
eg.E:\VScode-vue\transition&&animation.html

i.想同时使用动画和过渡，在enter-active-class和leave-active-class后面多加一个类:
eg.
enter-active-class="animated swing fade-enter-active"
leave-active-class="animated shake fade-leave-active"

ii.由于使用了过渡和动画，但俩者时长不一样:

如果我们想使用过渡的时长，加上type="transition";

如果想使用自定义，加上
  ：duration="10000"(单位毫秒)
如果想更详细，加上
  ：duration="{enter:5000;leave:3000;}"
  出场时长：5秒；退出时长3秒。

eg.
<transition 
    name="fade"
    :duration="{enter:5000,leave:3000}"
    appear
    enter-active-class="animated swing fade-enter-active"
    leave-active-class="animated shake fade-leave-active"
    appera-avtive-calss="animated swing"
    >
    <div v-if="show">hello world</div>
</transition>




///19.Vue中的js动画与Velocity.js的结合
eg.E:\VScode-vue\vue-js-velocity.html
i.js动画:
出场动画：（退场动画同理，enter改成leave）
    1.动画开始前触发before-enter事件；
    2.动画开始触发enter事件，函数有俩个参数：
      一个是触发事件的元素；
      一个是触发after-enter事件的函数；(必须)

eg.
<transition
      name="fade"
      @before-enter="handleBeforeEnter"
      @enter="handleEnter"
      @after-enter="handleAfterEnter"
    >
      <div>hello,shuaitong</div>
</transition>

methods:{
        handleBeforeEnter:function(el){
          el.style.color = 'red'
        },
        handleEnter:function(el,done){
          setTimeout(()=>{
            el.style.color = 'green'
          },2000);
          setTimeout(()=>{
            done()
          },4000);
        },
        handleAfterEnter:function(el){
          el.style.color = 'blue'
        }
      }

ii.js常用动画库 Velocity.js
 1.下载velocity.js库文件；
 2.引入库文件；
 3.在enter事件的函数中使用；
 格式：

  Velocity(el(元素),{样式变化},{配置})

eg.
handleEnter:function(el,done){
  Velocity(el,{
      opacity:1
  },{
      duration:1000, //动画时长，单位ms
      complete:done  //动画完成后触发的回调函数
  })
}



///20.Vue中多个元素或组件的过渡
i.多个元素过渡
<transition 
    mode="out-in"
>
  <div v-if="show" key="hello">hello world</div>
  <div v-else key="bye">bye world</div>
</transition>

css样式：
.v-enter,.v-leave-to{
   opacity:0;
}
.v-enter-active,.v-leave-active{
   transition:opacity 1s;
}

mode属性控制是入场动画先展示还是退场动画先展示：
out-in:先展示退场动画，再入场动画；
in-out:先展示入场动画，再退场动画；

ii.多个组件的过渡
同上，只不过用动态组件实现切换
<transition 
    mode="out-in"
>
  <component :is="type"></component>
</transition>


///21.Vue的列表过渡
使用transition-group标签包裹多个列表项：
相当于给每个列表项外面套上transition标签

<transition-group>
  <div v-for="item in list" :key="item.id">
      {{item.title}}
  <div>
</transition-group>

css样式：
.v-enter,.v-leave-to{
   opacity:0;
}
.v-enter-active,.v-leave-active{
   transition:opacity 1s;
}


///22.Vue中的动画封装
使用组件封装动画，在组件中实现动画，利用插槽将要实现动画的元素传入组件：
eg.E:\VScode-vue\vue-Animation packaging.html
父组件中：
 <div id="root">
    <fade >
        <div>hello,shuaitong</div>
    </fade>

    <fade >
      <h1>shuaitong</h1>>
    </fade>
 </div>

fade组件：
 Vue.component('fade',{
      props:['show'],
      template:`
        <transition
          appear
          appear-active-class="v-enter-active"
        >
          <slot ></slot>
        </transition>
      `
    })



///23.单文件组件与Vue中的路由
单文件组件：里面有三部分组成：
模板：template
逻辑:script
样式：style
（后缀：*.vue）

I.路由起步
  一.路由使用准备
   i.通过js文件导入vue.js和vue-router.js
   ii.使用模块的话：
    先安装vue-router: npm install vue-router --save
    然后导入：import Vue from 'vue'
             import Router from 'vue-router'
    最后使用：Vue.use(Router) 

  二.创建router实例,在实例中配置路由

    import Home from '@/pages/home/Home'
    import List from '@/pages/list/List'
    // @代表src目录
    // 导入要显示的单文件组件

    export default new Router({
    routes: [
        {
          path: '/',   
          name: 'Home',
          component: Home
        },
        {
          path: '/list',
          name: 'List',
          component: List
        }
      ]
    })


  三.将这个router实例对象导入到要使用路由的组件中  
    //在router这个文件夹中搜索路由配置文件，将router实例对象导入，命名为router
    import router from './router'

    //在组件中使用路由配置
    new Vue({
      el: '#app',
      router,  //缩写，键值相同时可以省略，router:router
      //使用后面router 这个里面的配置文件
      components: { App },
      template: '<App/>'
    })


  四.在使用路由的组件中加入<router-view>标签
    //路由就是根据网址的不同，返回不同的内容给用户

    i.<router-view>:
    <router-view> 组件是一个 functional 组件，渲染路径匹配到的视图组件。 
    eg.http://localhost:8080/#/list
    //显示的是当前路由地址所对应的内容,就会显示到组件List
    <router-view> 渲染的组件还可以内嵌自己的 <router-view>，根据嵌套路径，渲染嵌套组件。
    其他属性 (非 router-view 使用的属性) 都直接传给渲染的组件， 很多时候，每个路由的数据都是包含在路由参数中。
    因为它也是个组件，所以可以配合 <transition> 和 <keep-alive> 使用。如果两个结合一起用，要确保在内层使用 <keep-alive>：
        <transition>
          <keep-alive>
            <router-view></router-view>
          </keep-alive>
        </transition>
    router-view属性：
        name:默认值: "default"
        如果 <router-view>设置了名称，则会渲染对应的路由配置中 components 下的相应组件



    ii.<router-link>:
    <router-link> 组件支持用户在具有路由功能的应用中 (点击) 导航。 
    通过 to 属性指定目标地址，默认渲染成带有正确链接的 <a> 标签，可以通过配置 tag 属性生成别的标签。
    另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。
    //在 HTML5 history 模式下，router-link 会守卫点击事件，让浏览器不再重新加载页面。
    //当你在 HTML5 history 模式下使用 base 选项之后，所有的 to 属性都不需要写 (基路径) 了。
    router-link属性：
        i.to 
        表示目标路由的链接。当被点击后，内部会立刻把 to 的值传到 router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象。
        <!-- 字符串 -->
        <router-link to="home">Home</router-link>  // 渲染结果  <a href="home">Home</a>
        <router-link :to="'home'">Home</router-link> //使用 v-bind 的 JS 表达式 

        <!-- 描述目标位置的对象-->
        <router-link :to="{ path: 'home' }">Home</router-link>    
        //下面俩种可以用于传参
        <router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link> //有命名的路由
        <router-link :to="{ path: 'register', query: { plan: 'private' }}"
          >Register</router-link
        >//带查询参数，结果为 /register?plan=private 

        ii.replace
        设置 replace 属性的话，当点击时，会调用 router.replace() 而不是 router.push()，于是导航后不会留下 history 记录。
        eg.<router-link :to="{ path: '/abc'}" replace></router-link>

        iii.append
        设置 append 属性后，则在当前 (相对) 路径前添加基路径。例如，我们从 /a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b
        eg.<router-link :to="{ path: 'relative/path'}" append></router-link>

        iv.tag
        有时候想要 <router-link> 渲染成某种标签，例如 <li>。 于是我们使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航。
        eg.<router-link to="/foo" tag="li">foo</router-link>
         // 渲染结果    <li>foo</li>

        v.active-class
        默认值: "router-link-active"
        设置链接激活时使用的 CSS 类名。
        默认值可以通过路由的构造选项 linkActiveClass 来全局配置。

        vi.exact  和 exact-active-class
        “是否激活”默认类名的依据是包含匹配。 
        举个例子，如果当前的路径是 /a 开头的，那么 <router-link to="/a"> 也会被设置 CSS 类名。
        eg.<!-- 这个链接只会在地址为 / 的时候被激活 -->
            <router-link to="/" exact></router-link>

        exact-active-class
        默认值: "router-link-exact-active"
        配置当链接被精确匹配的时候应该激活的 class。
        注意默认值也是可以通过路由构造函数选项 linkExactActiveClass 进行全局配置的。


II.Router构建选项
    eg.const router = new router({
        mode:'history',
        routes:[{
            path:'/home',      //路径加在在bash后面，即 /app/home
            name:'home',
            component:Home
        }],
        bash:'/app/',
        linkActiveClass:'router-link-active',
        linkExactActiveClass:'router-link-exact-active',
        fallback:true,
        parseQuery:function(..){...},
        stringifyQuery:function(..){...},
        scrollerBehavior:function(...){...}
    })


   i.routes   
     类型: Array<RouteConfig>routes数组，其中的每个元素为路由配置选项RouteConfig对象：
          path: string, //路由路径

          component?: Component,//使用的组件

          name?: string, // 命名路由

          components?: { [name: string]: Component }, 
            // 命名视图组件 用于有多个
            eg.<router-view name="a">  <router-view name="b">
            components:{a:Home,b：List}  a命名视图组件使用Home组件，b命名视图组件使用List组件

          redirect?: string | Location | Function,
            //重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置,用于网站调整或网页被移到一个新地址,它也是通过 routes 配置来完成，下面例子是从 /a 重定向到 /b：
            eg.var router = new VueRouter({
                routes: [
                  { path: '/a', redirect: '/b' }
                ]
              })

            重定向的目标也可以是一个命名的路由：
            eg2.const router = new VueRouter({
                  routes: [
                    { path: '/a', redirect: { name: 'foo' }}
                  ]
                })

            甚至是一个方法，动态返回重定向目标：
            eg3.const router = new VueRouter({
                  routes: [
                    { path: '/a', redirect: to => {
                      // 方法接收 目标路由 作为参数
                      // return 重定向的 字符串路径/路径对象
                    }}
                  ]
                })


          alias?: string | Array<string>, 
            //路由路径的别名 /b 为/a的别名
            eg.path:'/a',alias:'/b',component:Home      当路径是/a或者/b 使用的都是Home组件

          props?: boolean | Object | Function, 
            //路由组件传参详解（3种模式）
            i.布尔模式
              如果 props 被设置为 true，route.params 将会被设置为组件属性。
              使用 props 将组件和路由解耦，取代与 $route 的耦合：
              eg.
              const User = {
                template: '<div>User {{ $route.params.id }}</div>'
              }
              const router = new VueRouter({
                routes: [
                  { path: '/user/:id', component: User }
                ]
              })

              通过 props 解耦：
              const User = {
                props: ['id'],
                template: '<div>User {{ id }}</div>'
              }
              const router = new VueRouter({
                routes: [
                  { path: '/user/:id', component: User, props: true },

                  // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：
                  {
                    path: '/user/:id',
                    components: { default: User, sidebar: Sidebar },
                    props: { default: true, sidebar: false }
                  }
                ]
              })

            ii.对象模式
               如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态的时候有用。
               eg.
               { path: '/static', component: Hello, props: { name: 'world' }}, //传递静态的值给Hello组件
               在Hello组件中使用props:['name']接收

            iii.函数模式
               创建一个函数返回 props.
               eg.URL /search?q=vue 会将 {q: 'vue'} 作为属性传递给 SearchUser 组件。
               const router = new VueRouter({
                routes: [
                  { path: '/search', component: SearchUser, props: (route) => ({ query: route.query.q }) }
                ] //参数route指this.$route，返回值为一个对象
              })
              在组件SearchUser中使用props:['query']接收


          children?: Array<RouteConfig>, 
            // 嵌套路由
            要在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置：
            const router = new VueRouter({
              routes: [
                { path: '/user/:id', component: User,
                  children: [
                    // 当 /user/:id 匹配成功，
                    // UserHome 会被渲染在 User 的 <router-view> 中
                    { 
                      path: '', 
                      component: UserHome 
                    },
                    {
                      // 当 /user/:id/profile 匹配成功，
                      // UserProfile 会被渲染在 User 的 <router-view> 中
                      path: 'profile',
                      component: UserProfile
                    },
                    {
                      // 当 /user/:id/posts 匹配成功
                      // UserPosts 会被渲染在 User 的 <router-view> 中
                      path: 'posts',
                      component: UserPosts
                    }
                  ]
                }
              ]
            })
            【要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。】


          beforeEnter?: (to: Route, from: Route, next: Function) => void,
          //看VII.路由守卫的路由配置守卫

          meta?: any,
          //路有元信息
          如何访问meta?
          routes 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录,
          一个路由匹配到的所有路由记录会暴露为 $route 对象 (还有在导航守卫中的路由对象) 的 $route.matched 数组。因此，我们需要遍历 $route.matched 来检查路由记录中的 meta 字段。

          eg.
          meta: { requiresAuth: true }

          router.beforeEach((to, from, next) => {
              if (to.matched.some(record => record.meta.requiresAuth)) {
                // 此路由需要验证，请检查是否已登录
                // if not, redirect to login page.
                if (!auth.loggedIn()) {
                  next({
                    path: '/login',
                    query: { redirect: to.fullPath }
                  })
                } else {
                  next()
                }
              } else {
                next() // 确保一定要调用 next()
              }
            })

          // 2.6.0+
          caseSensitive?: boolean, // 匹配规则是否大小写敏感？(默认值：false)

          pathToRegexpOptions?: Object // 编译正则的选项


    ii.mode
      类型: string
      默认值: "hash" (浏览器环境) | "abstract" (Node.js 环境)
      可选值: "hash" | "history" | "abstract"
      配置路由模式:
        .hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。
        .history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。
        .abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。
    
    iii.base
      类型: string
      默认值: "/"
      应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 "/app/"

    iv.linkActiveClass
      类型: string
      默认值: "router-link-active"
      全局配置 <router-link> 默认的激活的 class  

      linkExactActiveClass
      类型: string
      默认值: "router-link-exact-active"
      全局配置 <router-link> 默认的精确激活的 class。

    v.fallback
      类型: boolean
      当浏览器不支持 history.pushState 控制路由是否应该回退到 hash 模式。默认值为 true。
      在 IE9 中，设置为 false 会使得每个 router-link 导航都触发整页刷新。
      它可用于工作在 IE9 下的服务端渲染应用，因为一个 hash 模式的 URL 并不支持服务端渲染。

    vi.parseQuery / stringifyQuery
      类型: Function
      提供自定义查询字符串的解析/反解析函数。覆盖默认行为

    vii.scrollBehavior
      类型: Function
      //滚动行为
        这个功能只能在history模式下启用,
        参数：scrollBehavior 方法接收 to 和 from 路由对象。
        第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用。

        返回值：滚动位置的对象：
            {x:number,y:number}
            {selector:string}
      //如果返回的位置是虚假的或空的对象，return {} 或者  retern false
      //将保留当前滚动位置。


      eg.返回坐标
      var router=new VueRouter({
          routes:[],
          scrollBehavior(to,from,savedPosition){
              return {x:number,y:number}
          }
      })

      eg2.滚动到锚点：
        <li><router-link to="/about#red">红</router-link></li>
        <li><router-link to="/about#blue">蓝</router-link></li>

        scrollBehavior (to, from, savedPosition) {
        //判断如果滚动条的位置存在直接返回到当前位置，否者返回到起点
          if (savedPosition) {
              return savedPosition
          } else {
              if (to.hash) {   //看看hash值存不存在，to="/about#blue" hash值为blue,跳转到id='blue'的标签
                  return {selector: to.hash}
              }
              else return {x:0,y:0}
          }
       }

III.Router实例属性
    i.router.app
    类型: Vue instance
    配置了 router 的 Vue 根实例。

    ii.router.mode
    类型: string
    路由使用的模式。

    iii.router.currentRoute
    类型: Route
    当前路由对应的路由信息对象。即当前路由对象。


IV.Router实例方法
    i.动态的导航到一个新 URL。
      router.push(location, onComplete?, onAbort?)
      router.push(location).then(onComplete).catch(onAbort)

      //它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。
      router.replace(location, onComplete?, onAbort?) 
      router.replace(location).then(onComplete).catch(onAbort)
      
      router.go(n)  //类似 window.history.go(n)
      router.back()
      router.forward()

    ii.Router的导航守卫 
      router.beforeEach
      router.beforeResolve
      router.afterEach

    iii.router.getMatchedComponents:
        返回目标位置或是当前路由匹配的组件数组 (是数组的定义/构造类，不是实例)。通常在服务端渲染的数据预加载时使用。

        router.resolve:
        const resolved: {
            location: Location;
            route: Route;
            href: string;
        } = router.resolve(location, current?, append?)
        解析目标位置 (格式和 <router-link> 的 to prop 一样)。
          current 是当前默认的路由 (通常你不需要改变它)
          append 允许你在 current 路由上附加路径 (如同 router-link)

        router.addRoutes:
        router.addRoutes(routes: Array<RouteConfig>)
        动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组。  


        router.onReady:
        router.onReady(callback, [errorCallback])
          该方法把一个回调排队，在路由完成初始导航时调用，这意味着它可以解析所有的异步进入钩子和路由初始化相关联的异步组件。
          这可以有效确保服务端渲染时服务端和客户端输出的一致。
          第二个参数 errorCallback 只在 2.4+ 支持。它会在初始化路由解析运行出错 (比如解析一个异步组件失败) 时被调用。

        router.onError  
          router.onError(callback)
          注册一个回调，该回调会在路由导航过程中出错时被调用。
          注意被调用的错误必须是下列情形中的一种：
            错误在一个路由守卫函数中被同步抛出；
            错误在一个路由守卫函数中通过调用 next(err) 的方式异步捕获并处理；
            渲染一个路由的过程中，需要尝试解析一个异步组件时发生错误。

#router.addRoutes
V.route路由对象属性
    一个路由对象 (route object) 表示当前激活的路由的状态信息，包含了当前 URL 解析得到的信息，还有 URL 匹配到的路由记录 (route records)。
    路由对象是不可变 (immutable) 的，每次成功的导航后都会产生一个新的对象。
    路由对象出现在多个地方:
      .在组件内，即 this.$route
      .在 $route 观察者回调内
      .router.match(location) 的返回值
      .导航守卫的参数：
        router.beforeEach((to, from, next) => {
          // `to` 和 `from` 都是路由对象
        })
      .scrollBehavior 方法的参数:
        const router = new VueRouter({
          scrollBehavior(to, from, savedPosition) {
            // `to` 和 `from` 都是路由对象
          }
        })

    i.$route.path
    类型: string
    字符串，对应当前路由的路径，总是解析为绝对路径，如 "/foo/bar"。

    ii.$route.params
    类型: Object
    一个 key/value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。
    eg.<router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link> //有命名的路由
       或者
       在配置路由中，{path:'/user/:id',name:'user',component:User}
       当访问/user/123,$route.params.id === 123


    iii.$route.query
    类型: Object
    一个 key/value 对象，表示 URL 查询参数。
    例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。
    eg.<router-link :to="{path:'/user',query:{id:123}}">
      当点击时，url链接为：/usr?id=123,$route.query.id===123


    iv.$route.hash
    类型: string
    当前路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串

    v.$route.fullPath
    类型: string
    完成解析后的 URL，包含查询参数和 hash 的完整路径。

    vi.$route.name  和 $route.redirectedFrom
    当前路由的名称，如果有的话。(查看命名路由)
    和
    如果存在重定向，即为重定向来源的路由的名字。(参阅重定向和别名)

    vii.$route.matched
    类型: Array<RouteRecord>
    一个数组，包含当前路由的所有嵌套路径片段的路由记录 。
    路由记录就是 routes 配置数组中的对象副本 (还有在 children 数组)。
    const router = new VueRouter({
      routes: [
        // 下面的对象就是路由记录
        {
          path: '/foo',
          component: Foo,
          children: [
            // 这也是个路由记录
            { path: 'bar', component: Bar }
          ]
        }
      ]
    })
    当 URL 为 /foo/bar，$route.matched 将会是一个包含从上到下的所有对象 (副本)。




VI.动态路由匹配
  i.动态路径参数”(dynamic segment)：
  【一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。】
  模式                                  匹配路径                  $route.params
  /user/:username                      /user/evan                { username: 'evan' }
  /user/:username/post/:post_id        /user/evan/post/123       { username: 'evan', post_id: '123' }   

  eg.有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染
  const User = {
  template: '<div>User {{ $route.params.id }}</div>'
  }

  const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头
    { path: '/user/:id', component: User }
    ]
  })
  
  访问不同id ： http://localhost:8080/user/evan  或者  http://localhost:8080/user/shuaitong         
  结果访问的都是User组件，只不过对应的$route.params.id值不同，一个是evan，一个是shuaitong

  ii.响应路由参数的变化
    当使用路由参数时，例如从 /user/foo 导航到 /user/bar，原来的组件实例会被复用。
    因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。
    不过，这也意味着组件的生命周期钩子不会再被调用。
    解决方法：
    复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) $route 对象：
      const User = {
        template: '...',
        watch: {
          '$route' (to, from) {// `to` 和 `from` 都是路由对象
            // 对路由变化作出响应...
          }
        }
      }
      或者
    使用 2.2 中引入的 beforeRouteUpdate 导航守卫：
      const User = {
        template: '...',
        beforeRouteUpdate (to, from, next) {
          // react to route changes...
          // don't forget to call next()
        }
      }


【当使用一个通配符时，$route.params 内会自动添加一个名为 pathMatch 参数。
它包含了 URL 通过通配符被匹配的部分：
  // 给出一个路由 { path: '/user-*' }
  this.$router.push('/user-admin')
  this.$route.params.pathMatch // 'admin'
  // 给出一个路由 { path: '*' }
  this.$router.push('/non-existing')
  this.$route.params.pathMatch // '/non-existing'
】
【当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 { path: '*' } 通常用于客户端 404 错误。】
【匹配优先级：有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。】 



VII.导航守卫
  【正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。
  导航过程中有多种机会植入路由：全局的, 单个路由独享的, 或者组件级的。

  记住参数或查询的改变并不会触发进入/离开的导航守卫。
  你可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。
  】
  完整的导航解析流程：
        1.导航行为被触发，此时导航未被确认。
        2.在失活的组件里调用离开守卫 beforeRouteLeave。
        3.调用全局的 beforeEach(function) 守卫。
        4.在重用的组件里调用 beforeRouteUpdate:function 守卫 (2.2+)。
        5.在路由配置里调用 {path: '/',beforeEnter:function} 。
        6.解析异步路由组件（如果有）。
        7.在被激活的组件里调用 beforeRouteEnter。
        8.调用全局的 beforeResolve(function) 守卫 (2.5+)，标示解析阶段完成。
        9.导航被确认。
        10.调用全局的 afterEach(function) 钩子。
        11.非重用组件，开始组件实例的生命周期
            beforeCreate&created
            beforeMount&mounted
        12.触发 DOM 更新。
        13.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。
        14.导航完成



  i.全局前置守卫
    使用 router.beforeEach 注册一个全局前置守卫：
      const router = new VueRouter({ ... })
      router.beforeEach((to, from, next) => {
          // ...
      })
      当一个导航触发时，全局前置守卫按照创建顺序调用。
      守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中。

      每个守卫方法接收三个参数：
        to: Route: 即将要进入的目标 路由对象
        from: Route: 当前导航正要离开的路由
        next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。

         .next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。

         .next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。

         .next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。

         .next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。

      确保要调用 next 方法，否则钩子就不会被 resolved。

      eg.
        router.beforeEach((to,from,next)=>{
           if (to.path == '/food') {
               alert('还没登录，请先登录');
               next('/drinks');
           } else {
               next();
           }
        })



  ii.全局解析守卫(2.5.0+)
    router.beforeResolve 注册一个全局守卫。
    这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。


  iii.全局后置钩子
    注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：

    router.afterEach((to, from) => {
      // ...
    })


  vi.路由独享的守卫
    你可以在路由配置上直接定义 beforeEnter 守卫：

    const router = new VueRouter({
      routes: [
        {
          path: '/foo',
          component: Foo,
          beforeEnter: (to, from, next) => {
            // ...
          }
        }
      ]
    })
    这些守卫与全局前置守卫的方法参数是一样的。
    eg.
       {
          path: '/',
          name: "home",
          component: Home,
          // 路由独享守卫
          beforeEnter: (to, from, next) => {
            if(from.name === 'about'){
              alert("这是从about来的")
            }else{
              alert("这不是从about来的")
            }
            next();  // 必须调用来进行下一步操作。否则是不会跳转的
          }
        }


  v.组件内的守卫
    路由组件内直接定义以下路由导航守卫：
      beforeRouteEnter  :进入路由前
      【beforeRouteEnter触发在导航确认、组件实例创建之前：beforeCreate之前；
      而next中函数的调用在mounted之后：为了确保能对组件实例的完整访问】

      beforeRouteUpdate (2.2 新增):路由复用同一个组件时
      beforeRouteLeave  :离开当前路由时

    const Foo = {
      template: `...`,
      beforeRouteEnter (to, from, next) {
        // 在渲染该组件的对应路由被 confirm 前调用
        // 不！能！获取组件实例 `this`
        // 因为当守卫执行前，组件实例还没被创建
      },
      beforeRouteUpdate (to, from, next) {
        // 在当前路由改变，但是该组件被复用时调用
        // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
        // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
        // 可以访问组件实例 `this`
      },
      beforeRouteLeave (to, from, next) {
        // 导航离开该组件的对应路由时调用
        // 可以访问组件实例 `this`
      }
    }

    【beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。】

    解决方法：
      通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。
    eg.
        beforeRouteEnter (to, from, next) {
          next(vm => {
            // 通过 `vm` 访问组件实例
          })
        }

    【
     注意 beforeRouteEnter 是支持给 next 传递回调的唯一守卫。
     对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。
    】
    eg.
      beforeRouteUpdate (to, from, next) {
        // just use `this`
        this.name = to.params.name
        next()
      }

    【离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。】
    eg.
      beforeRouteLeave (to, from , next) {
        const answer = window.confirm('Do you really want to leave? you have unsaved changes!')
        if (answer) {
          next()
        } else {
          next(false)
        }
      }


///24.多页应用和单页应用
多页面应用：
页面跳转->返回HTML
优点：首屏时间快(只需要一个请求)，seo效果好
缺点：页面切换慢

单页应用：
页面跳转->js渲染
优点：页面切换快
确点：首屏事件稍慢，seo差


 










////npm指令
1.创建项目
vue init webpack 项目名

2.进入目录
npm run dev 

3.打包
npm run build
////配置
1.移动端meta标签设置：
<meta name="viewport" content="maximum-scale=1.0,minimum-scale=1.0,user-scalable=0,width=device-width,initial-scale=1.0"/>

//作用：在移动浏览器中，当页面宽度超出设备，浏览器内部虚拟的一个页面容器，将页面容器缩放到设备那么大展示；

//视口的宽度可以通过meta标签设置；
//此属性为移动端页面视口设置；
//width：视口的宽度，width=device-width：宽度是设备的宽度
//initial-scale：初始化缩放，- initial-scale=1.0：不缩放
//user-scalable：是否允许用户自行缩放，取值0或1，yes或no
//minimum-scale：最小缩放
//maximum-scale：最大缩放
一般设置了不允许缩放，就没必要设置最大最小缩放了。

【
  npm常用命令：
    *npm install -g 包名      (加上-g为全局安装，无指定版本号安装最新版本)
    *npm install -g 包名@版本号  （指定版本下载）    
    *npm uninstall 包名 -g    (加上-g为全局卸载)
    *npm update -g  包名      （更新包到最新版本）
    *npm init   初始化一个包
      进入包的目录，node . 运行package.json中main指向的文件
      或者
      进入包的目录，package.json中有一个脚本"scripts":{"test":node index.js}
      执行npm run test

    *npm install  包名 --save 生产环境（项目部署上线之后的服务器环境）
        向生产环境添加依赖dependencies,在package.json文件中
    *npm install --production  安装在package.json文件中dependencies的所有依赖
    如果只有npm install 就是安装所有依赖，包括生产和开发环境的依赖

    *npm install  包名 --save-dev 开发环境（平时开发使用的环境）
        向开发环境添加依赖devDependencies,在package.json文件中
    上传代码时是不会上传node_modules中的文件，所以需要根据package.json中的dependencies去下载对应的依赖
】



2. 1rem = html font-size =50px (导入的css文件规定了)

3.安装stylus 和 stylus-loader
//在style加上lang属性，值为stylus，方便写css,
//为了保证css样式只对该组件生效，在style加上scoped
eg.一个大的div里面有三个小的div

<style lang="stylus" scoped>
    .header
        display:flex
        height: .86rem
        line-height: .86rem
        background:#00bcd4
        color:#fff
        .header-left
            width: .64rem
            float: left
        .header-input
            flex:1
            margin-top:.12rem
            margin-left: .2rem
            height :.64rem
            line-height: .64rem
            color:#ccc
            background: #fff
            border-radius :.1rem
        .header-right
            width: 1.24rem
            float: right
            text-align:center
</style>




4.
先使用iconfont 官网寻找图标，下载
然后将字体文件和iconfont.css拉进项目，iconfont.css里面需要对字体文件的路劲进行修改
最后导入iconfont.css文件

eg.使用iconfont类，然后内容使用unicode代码
<span class="iconfont">&#xe669;</span>


5.在样式中引入*.styl文件
eg.
<style lang="stylus" scoped>
@import '~@/assets/styles/varibles.styl';
//@符合代表src目录，但是在css中前面要加上~
 .header
        display:flex
        height: .86rem
        line-height: .86rem
        background:$bgColor

在varibles.styl文件中定义：
$bgColor = red


6.build目录下的webpack.base.conf.js文件中
module.exports ={
  
  resolve: {
    extensions: ['.js', '.vue', '.json'],
    alias: {
      'vue$': 'vue/dist/vue.esm.js',
      '@': resolve('src'),
      'styles':resolve('src/assets/styles')
      //自己加上自定义目录
    }
  }
}

7.使用轮播插件 vue-awesome-swiper
安装：
npm install vue-awesome-swiper@2.6.7 --save
引入：
import VueAwesomeSwiper from 'vue-awesome-swiper'
引入css：
import 'swiper/dist/css/swiper.css'
使用插件：
Vue.use(VueAwesomeSwiper, /* { default global options } */)


在组件的template中加入
  <swiper :options="swiperOption" ref="mySwiper" @someSwiperEvent="callback">
    <!-- slides -->
    <swiper-slide>I'm Slide 1</swiper-slide>
    <swiper-slide>I'm Slide 2</swiper-slide>
    <swiper-slide>I'm Slide 3</swiper-slide>
    <swiper-slide>I'm Slide 4</swiper-slide>
    <swiper-slide>I'm Slide 5</swiper-slide>
    <swiper-slide>I'm Slide 6</swiper-slide>
    <swiper-slide>I'm Slide 7</swiper-slide>

    <!-- Optional controls -->
    <div class="swiper-pagination"  slot="pagination"></div>
    <div class="swiper-button-prev" slot="button-prev"></div>
    <div class="swiper-button-next" slot="button-next"></div>
    <div class="swiper-scrollbar"   slot="scrollbar"></div>
  </swiper> 

i.swiper-slide组件指的是轮播的内容，里面可以放图片,
可以使用数组遍历：
eg.
<swiper-slide  v-for="item of swiperList" :key='item.id'>
        <img class="swiper-image" :src="item.url" >     
</swiper-slide>


ii.下面四个div是选项控制:
第一个是图片对应的白点栏
第二个是上一个按钮
第三个是下一个按钮
第四个是滑动条

iii.swiper组件中有个绑定属性:options="swiperOption"
eg.
data (){
        return {
            swiperOption: {
                pagination:'.swiper-pagination',
                //给name为pagination的插槽传使用的css
                loop:true
                //图片循环
            }
        }
    }

iv.解决图片加载前高度为0问题：
 .wrapper
        overflow hidden
        width 100%
        height 0
        padding-bottom 31.25%
      .swiper-image 
         width 100%
不能用hight的百分比，其对应的是父元素的高度；
padding的百分比对应的是width。

使用样式给自己归定一片空间
eg.
   .div{
       overflow :hidden;
       height:0;
       width:100px;
       padding-bottom:100px;
   }

这样即使没有内容也会给自己一个宽100px，高100px的区域


v.使用>>>穿透
问题：
图片对应的点的样式由以下俩个类控制，但这个俩个类都在子组件中，由于scoped，在父组件修改是没用的：
swiper-pagination-bullet swiper-pagination-bullet-active


解决方法：
.wrapper >>> .swiper-pagination-bullet-active
        background #fff ！important

//让.wrapper下面所有子组件出现.swiper-pagination-bullet-active使用该样式


vi.可以使用*.styl文件封装css样式
eg.在mixis.styl文件中
  ellipsis()
      overflow hidden
      text-overflow ellipsis
      white-space nowrap

使用直接调用函数就行




8.axios
config目录下的index.js

设置代理proxyTable:
proxyTable: {
      '/api' :{
        target:'http://localhost:8080',
        pathRewrite:{
          '^/api': '/static/mock/'
        }
      }
代理网址：http://localhost:8080
路劲重写：当开头为/api 转化为 /static/mock