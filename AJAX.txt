AJAX 简介
AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。

【为什么会有跨域？那必须得说同源政策，同源指的是三个同源：1，协议相同，域名相同，端口相同，例如http://y.localhost.com:7001/public/3.html；这些网址协议是http://域名是y.localhost.com:，端口号是7001，在这三个都相同的话就是同源
同源：http://y.localhost.com:7001/public/5.html，
同域不同端口http://y.localhost.com:7002/public/3.html，
协议不同https://y.localhost.com:7001/public/3.html
域不同http://x.localhost.com:7001/public/3.html,

不同源的网址不能不可以共享cookie，LocalStorage ，dom也无法获取，ajax不能发送，防止了恶意的网站窃取数据，保证了用户信息的安全，所以同源政策是必须的，
】



什么是 AJAX ？
		AJAX = 异步 JavaScript 和 XML。
		AJAX 是一种用于创建快速动态网页的技术。
		通过在后台与服务器进行少量数据交换异步更新，AJAX可以使网页实现。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。
		传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。



I.
AJAX - XMLHttpRequest 对象:Ajax 的核心是 XMLHttpRequest 对象。

XMLHttpRequest 对象：
所有现代浏览器都支持 XMLHttpRequest 对象。
XMLHttpRequest 对象用于同幕后服务器交换数据。这意味着可以更新网页的部分，而不需要重新加载整个页面。



///XMLHttpRequest 对象属性:
onreadystatechange					定义当 readyState 属性发生变化时被调用的函数
									eg.xmlhttp = new XMLHttpRequest();
										xmlhttp.onreadystatechange = function(){...}

readyState							保存 XMLHttpRequest 的状态。
									0：请求未初始化
									1：服务器连接已建立
									2：请求已收到
									3：正在处理请求
									4：请求已完成且响应已就绪		

responseText						以字符串返回响应数据	
									eg.myObj = JSON.parse(this.responseText);   //将收到的JSON字符串转化为对象

responseXML						    以 XML 数据返回响应数据	返回一个XML 文档	


status							    返回请求的状态号
									200: "OK"
									403: "Forbidden"
									404: "Not Found"

statusText							返回状态文本（比如 "OK" 或 "Not Found"）

		











///XMLHttpRequest 对象方法:
new XMLHttpRequest()				创建新的 XMLHttpRequest 对象
abort()								取消当前请求
getAllResponseHeaders()				返回头部信息
getResponseHeader(x)				返回特定的头部信息  x为特定的头部名称

setRequestHeader(header,value)	    向要发送的报头添加标签/值对
									向请求添加 HTTP 头。
										header: 规定头的名称
										value: 规定头的值
									eg.xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");


send()								将请求发送到服务器，用于 GET 请求
send(string)						将请求发送到服务器，用于 POST 请求

open(method, url, async, user, psw)	
									规定请求
									method：请求类型 GET 或 POST
									url：文件位置
									async：true（异步）或 false（同步）
									user：可选的用户名称
									psw：可选的密码






创建 XMLHttpRequest 对象：
所有现代浏览器（Chrom、IE7+、Firefox、Safari 以及 Opera）都有内建的 XMLHttpRequest 对象。
创建 XMLHttpRequest 的语法是：
variable = new XMLHttpRequest();

老版本的 Internet Explorer（IE5 和 IE6）使用 ActiveX 对象：
variable = new ActiveXObject("Microsoft.XMLHTTP");

考虑版本兼容：
var xhttp;
if (window.XMLHttpRequest) {
    xhttp = new XMLHttpRequest();
    } else {
    // code for IE6, IE5
     xhttp = new ActiveXObject("Microsoft.XMLHTTP");
}


【
跨域访问：
出于安全原因，现代浏览器不允许跨域访问。
这意味着尝试加载的网页和 XML 文件都必须位于相同服务器上。
W3School 上的实例都会打开位于 W3School 域上的 XML 文件。
如果您希望在自己的页面上使用以上实例，那么您所加载的 XML 文件必须位于您自己的服务器上。
】










AJAX - 向服务器发送请求：
向服务器发送请求
如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：
xmlhttp.open("GET","test1.txt",true);
xmlhttp.send();

open(method, url, async, user, psw)	
									规定请求
									method：请求类型 GET 或 POST
									url：服务器上的文件(该文件可以是任何类型的文件)
									async：true（异步）或 false（同步）									
									user：可选的用户名称
									psw：可选的密码

异步 - True 或 False？
AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。
XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true：
xhttp.open("GET", "ajax_test.asp", true);

通过异步发送，JavaScript 不必等待服务器响应，而是可以：
	在等待服务器响应时执行其他脚本
	当响应就绪时处理响应



GET 还是 POST？
与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。
然而，在以下情况中，请使用 POST 请求：
	无法使用缓存文件（更新服务器上的文件或数据库）
	向服务器发送大量数据（POST 没有数据量限制）
	发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠









AJAX - 服务器响应:
readyState 				 属性存留 XMLHttpRequest 的状态。
onreadystatechange 		 属性定义当 readyState 发生变化时执行的函数。
status 属性和 statusText  属性存有 XMLHttpRequest 对象的状态。

每当 readyState 发生变化时就会调用 onreadystatechange 函数。
readyState:
0：请求未初始化
1：服务器连接已建立
3：正在处理请求
4：请求已完成且响应已就绪	

status:
200: "OK"
403: "Forbidden"   //禁止
404: "Not Found"   //找不到

当 readyState 为 4，status 为 200 时，响应就绪：
eg.
function loadDoc() {
    var xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
            document.getElementById("demo").innerHTML =
            this.responseText;
       }
    };
    xhttp.open("GET", "ajax_info.txt", true);
    xhttp.send(); 
} 

(注释：onreadystatechange 被触发五次（0-4），每次 readyState 都发生变化。)



使用回调函数：
回调函数是一种作为参数被传递到另一个函数的函数。
如果您的网站中有多个 AJAX 任务，那么您应该创建一个执行 XMLHttpRequest 对象的函数，以及一个供每个 AJAX 任务的回调函数。
该函数应当包含 URL 以及当响应就绪时调用的函数。
eg.
<button type="button" onclick="loadDoc('/example/js/ajax_info.txt', myFunction)">
																	//myFunction为回调函数的引用

<script>
function loadDoc(url, cFunction) {
  var xhttp;
  xhttp=new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      cFunction(this);          //使用回调函数
    }
  };
  xhttp.open("GET", url, true);
  xhttp.send();
}
//回调函数：
function myFunction(xhttp) {
  document.getElementById("demo").innerHTML =
  xhttp.responseText;
}
</script>

服务器响应属性:
//responseText			responseText 属性以 JavaScript 字符串的形式返回服务器响应
eg.document.getElementById("demo").innerHTML = xhttp.responseText;


//responseXML			XML HttpRequest 对象有一个內建的 XML 解析器。
						ResponseXML 属性以 XML DOM 对象返回服务器响应。
						使用此属性，您可以把响应解析为 XML DOM 对象。
eg.
xhttp = new XMLHttpRequest();
xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    xmlDoc = this.responseXML;                   //获得XML文档
    txt = "";
    x = xmlDoc.getElementsByTagName("ARTIST");   //获取文档中标签名为ARTIST 的一个数组
    for (i = 0; i < x.length; i++) {
      txt = txt + x[i].childNodes[0].nodeValue + "<br>";  //每个元素节点的第一个孩子节点是文本结点
    }
    document.getElementById("demo").innerHTML = txt;
  }
};
xhttp.open("GET", "/demo/music_list.xml", true);
xhttp.send();




服务器响应方法：
//getAllResponseHeaders() 方法：返回所有来自服务器响应的头部信息。
eg.
document.getElementById("demo").innerHTML = this.getAllResponseHeaders();
输出：date: Mon, 19 Aug 2019 14:55:26 GMT 
      content-encoding: gzip         
      etag: "79dac03a2e11d51:0" 
      last-modified: Thu, 23 May 2019 06:10:32 GMT 
      server: Microsoft-IIS/10.0 
      x-powered-by: ASP.NET 
      vary: Accept-Encoding 
      content-type: text/plain 
      status: 304     
      cache-control: no-cache,no-cache 
      accept-ranges: bytes 
      content-length: 306



//getResponseHeader("attr") 方法:返回来自服务器响应的特定头部信息。
 eg.document.getElementById("demo").innerHTML = this.getResponseHeader("Last-Modified");



POST：发送数据至服务器
创建一个如下的HTTP 请求：

POST /foo.php HTTP/1.1
Host: localhost
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5 (.NET CLR 3.5.30729)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Referer: http://localhost/test.php
Content-Type: application/x-www-form-urlencoded
Content-Length: 43
first_name=John&last_name=Doe&action=Submit



 II.
 AJAX ASP/PHP 请求实例
 AJAX PHP 实例：当用户在输入字段中键入字符时，会执行名为 "showHint()" 的函数。
 html：
 <html>
<head>
<script>
function showHint(str) {
    if (str.length == 0) { 
        document.getElementById("txtHint").innerHTML = "";
        return;
    } else {
        var xmlhttp = new XMLHttpRequest();
        xmlhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                document.getElementById("txtHint").innerHTML = this.responseText;
            }
        };
        xmlhttp.open("GET", "gethint.php?q=" + str, true);
        xmlhttp.send();
    }
}
</script>
</head>
<body>

<p><b>请在下面的输入字段中键入姓名：</b></p>
<form> 
姓或名：<input type="text" onkeyup="showHint(this.value)"> 
</form>
<p>建议：<span id="txtHint"></span></p>
</body>
</html>


php:
<?php
// 姓名数组
 $a[] = "Ava";
 $a[] = "Brielle";
 $a[] = "Caroline";
 $a[] = "Diana";
 $a[] = "Elise";
 $a[] = "Fiona";
 $a[] = "Grace";
 $a[] = "Hannah";
 $a[] = "Ileana";
 $a[] = "Jane";
 $a[] = "Kathryn";
 $a[] = "Laura";
 $a[] = "Millie";
 $a[] = "Nancy";
 $a[] = "Opal";
 $a[] = "Petty";
 $a[] = "Queenie";
 $a[] = "Rose";
 $a[] = "Shirley";
 $a[] = "Tiffany";
 $a[] = "Ursula";
 $a[] = "Victoria";
 $a[] = "Wendy";
 $a[] = "Xenia";
 $a[] = "Yvette";
 $a[] = "Zoe";
 $a[] = "Angell";
 $a[] = "Adele";
 $a[] = "Beatty";
 $a[] = "Carlton";
 $a[] = "Elisabeth";
 $a[] = "Violet";

// 从 URL 获取 q 参数
$q = $_REQUEST["q"];

$hint = "";

// 查看数组中所有 hint，$q 是否与 "" 相同
if ($q !== "") {
    $q = strtolower($q);       //类似js中的toLowerCase()
    $len=strlen($q);
    foreach($a as $name) {       //php 中 foreach($array as $value)   
        if (stristr($q, substr($name, 0, $len))) {
            if ($hint === "") {
                $hint = $name;            
            } else {
                $hint .= ", $name";
            }
         }
    }
}

// 输出 "no suggestion"，如果未找到 hint 或输出正确的值
  echo $hint === "" ? "no suggestion" : $hint;
?>






AJAX ASP 实例:
ASP 文件 - "gethint.asp"
这个 ASP 文件检查姓名数组，然后向浏览器返回对应的姓名：

<%
 response.expires=-1
 dim a(32)
 '用姓名填充数组
 a(1)="Ava"
 a(2)="Brielle"
 a(3)="Caroline"
 a(4)="Diana"
 a(5)="Elise"
 a(6)="Fiona"
 a(7)="Grace"
 a(8)="Hannah"
 a(9)="Ileana"
 a(10)="Jane"
 a(11)="Kathryn"
 a(12)="Laura"
 a(13)="Millie"
 a(14)="Nancy"
 a(15)="Opal"
 a(16)="Petty"
 a(17)="Queenie"
 a(18)="Rose"
 a(19)="Shirley"
 a(20)="Tiffany"
 a(21)="Ursula"
 a(22)="Victoria"
 a(23)="Wendy"
 a(24)="Xenia"
 a(25)="Yvette"
 a(26)="Zoe"
 a(27)="Angell"
 a(28)="Adele"
 a(29)="Beatty"
 a(30)="Carlton"
 a(31)="Elisabeth"
 a(32)="Violet"

 '从 URL 获取 q 参数
 q=ucase(request.querystring("q"))

 '查看数组中所有 hint，q 的长度是否大于 0
 if len(q)>0 then
   hint=""
   for i=1 to 30
     if q=ucase(mid(a(i),1,len(q))) then
       if hint="" then
         hint=a(i)
       else
         hint=hint & " , " & a(i)
       end if
     end if
   next
 end if

 '如果未找到 hint，输出 "no suggestion"，或输出正确的值
 if hint="" then
   response.write("no suggestion")
 else
   response.write(hint)
 end if
%>





III.
AJAX 数据库实例
当用户在上面的下拉列表中选择某个客户时，会执行名为 "showCustomer()" 的函数。该函数由 "onchange" 事件触发：
function showCustomer(str)
{
var xmlhttp;
if (str=="")
  {
  document.getElementById("txtHint").innerHTML="";
  return;
  }
if (window.XMLHttpRequest)
  {// code for IE7+, Firefox, Chrome, Opera, Safari
  xmlhttp=new XMLHttpRequest();
  }
else
  {// code for IE6, IE5
  xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
  }
xmlhttp.onreadystatechange=function()
  {
  if (xmlhttp.readyState==4 && xmlhttp.status==200)
    {
    document.getElementById("txtHint").innerHTML=xmlhttp.responseText;
    }
  }
xmlhttp.open("GET","getcustomer.asp?q="+str,true);
xmlhttp.send();
}


AJAX 服务器页面
由上面的 JavaScript 调用的服务器页面是 ASP 文件，名为 "getcustomer.asp"。
<%
response.expires=-1
sql="SELECT * FROM CUSTOMERS WHERE CUSTOMERID="
sql=sql & "'" & request.querystring("q") & "'"

set conn=Server.CreateObject("ADODB.Connection")
conn.Provider="Microsoft.Jet.OLEDB.4.0"
conn.Open(Server.Mappath("/db/northwind.mdb"))
set rs=Server.CreateObject("ADODB.recordset")
rs.Open sql,conn

response.write("<table>")
do until rs.EOF
  for each x in rs.Fields
    response.write("<tr><td><b>" & x.name & "</b></td>")
    response.write("<td>" & x.value & "</td></tr>")
  next
  rs.MoveNext
loop
response.write("</table>")
%>





////常用标准请求头字段
Accept 设置接受的内容类型
    Accept: text/plain

Accept-Charset 设置接受的字符编码
    Accept-Charset: utf-8

Accept-Encoding 设置接受的编码格式
    Accept-Encoding: gzip, deflate

Accept-Datetime 设置接受的版本时间
    Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT

Accept-Language 设置接受的语言
    Accept-Language: en-US

Authorization 设置HTTP身份验证的凭证
    Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==

Cache-Control 设置请求响应链上所有的缓存机制必须遵守的指令
    Cache-Control: no-cache //告知服务器客户端不直接使用缓存，要求向原服务器发起请求
                   no-store //所有内容都不会被保存到缓存或者internet临时文件
                   max-age=number-seconds //告知服务器客户端希望接收一个存在时间不大于number-seconds秒的资源
                   max-stale[=number-seconds] //告知服务器客户端愿意接收一个超过缓存时间的资源：
                                                  若有定义number-seconds，则为number-seconds秒；
                                                  没有定义，则为超出任意时间
                   min-fresh=number-seconds 
                                          //告知服务器客户端希望接收一个在小于number-seconds秒内被更新的过的资源
                   no-transform         //告知服务器客户端希望获取实体数据没有被转换（比如压缩）过的资源
                   only-if-cached    //告知服务器客户端希望获取缓存的内容（若有），而不用向原服务器发送请求。

Connection 设置当前连接和hop-by-hop协议请求字段列表的控制选项
                  Connection: keep-alive
                  Connection: Upgrade

Content-Length 设置请求体的字节长度
                  Content-Length: 348

Content-MD5 设置基于MD5算法对请求体内容进行Base64二进制编码
                  Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==

Content-Type 设置请求体的MIME类型（适用POST和PUT请求）
                  Content-Type: application/x-www-form-urlencoded

Cookie 设置服务器使用Set-Cookie发送的http cookie
                  Cookie: $Version=1; Skin=new;

Date 设置消息发送的日期和时间
                  Date: Tue, 15 Nov 1994 08:12:31 GMT

Expect 标识客户端需要的特殊浏览器行为
                  Expect: 100-continue

Forwarded 披露客户端通过http代理连接web服务的源信息
                  Forwarded: for=192.0.2.60;proto=http;by=203.0.113.43
                  Forwarded: for=192.0.2.43, for=198.51.100.17
Max-Forwards 限制代理或网关转发消息的次数
                  Max-Forwards: 10


From 设置发送请求的用户的email地址
                  From: user@example.com

Host 设置服务器域名和TCP端口号，如果使用的是服务请求标准端口号，端口号可以省略
                  Host: en.wikipedia.org:8080
                  Host: en.wikipedia.org

If-Match 设置客户端的ETag,当时客户端ETag和服务器生成的ETag一致才执行，适用于更新自从上次更新之后没有改变的资源
                  If-Match: "737060cd8c284d8af7ad3082f209582d

If-None-Match 设置客户端ETag，如果和服务端接受请求生成的ETage相同，允许服务端返回304 Not Modified
                  If-None-Match: "737060cd8c284d8af7ad3082f209582d"

If-Modified-Since 设置更新时间，从更新时间到服务端接受请求这段时间内如果资源没有改变，允许服务端返回304 Not Modified
                  If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT


If-Range 设置客户端ETag，如果和服务端接受请求生成的ETage相同，返回缺失的实体部分；否则返回整个新的实体
                  If-Range: "737060cd8c284d8af7ad3082f209582d"


If-Unmodified-Since 设置更新时间，只有从更新时间到服务端接受请求这段时间内实体没有改变，服务端才会发送响应
                  If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT



Origin 标识跨域资源请求（请求服务端设置Access-Control-Allow-Origin响应字段）
                  Origin: http://www.example-social-network.com

Pragma 设置特殊实现字段，可能会对请求响应链有多种影响
                  Pragma: no-cache

Proxy-Authorization 为连接代理授权认证信息
                  Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==

Range 请求部分实体，设置请求实体的字节数范围，具体可以参见HTTP/1.1中的Byte serving
                  Range: bytes=500-999

Referer 设置前一个页面的地址，并且前一个页面中的连接指向当前请求，意思就是如果当前请求是在A页面中发送的，那么referer就是A页面的url地址（轶事：这个单词正确的拼法应该是"referrer",但是在很多规范中都拼成了"referer"，所以这个单词也就成为标准用法）
                  Referer: http://en.wikipedia.org/wiki/Main_Page

TE 设置用户代理期望接受的传输编码格式，和响应头中的Transfer-Encoding字段一样
                  TE: trailers, deflate

Upgrade 请求服务端升级协议
                  Upgrade: HTTP/2.0, HTTPS/1.3, IRC/6.9, RTA/x11, websocket

User-Agent 用户代理的字符串值
                  User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0

Via 通知服务器代理请求
                  Via: 1.0 fred, 1.1 example.com (Apache/1.1)

Warning 实体可能会发生的问题的通用警告
                  Warning: 199 Miscellaneous warning

///常用非标准请求头字段：

X-Requested-With 标识Ajax请求，大部分js框架发送请求时都会设置它为XMLHttpRequest
                  X-Requested-With: XMLHttpRequest

DNT 请求web应用禁用用户追踪
                  DNT: 1 (Do Not Track Enabled)
                  DNT: 0 (Do Not Track Disabled)

X-Forwarded-For 一个事实标准，用来标识客户端通过HTTP代理或者负载均衡器连接的web服务器的原始IP地址
                  X-Forwarded-For: client1, proxy1, proxy2
                  X-Forwarded-For: 129.78.138.66, 129.78.64.103

X-Forwarded-Host 一个事实标准，用来标识客户端在HTTP请求头中请求的原始host,因为主机名或者反向代理的端口可能与处理请求的原始服务器不同
                  X-Forwarded-Host: en.wikipedia.org:8080
                  X-Forwarded-Host: en.wikipedia.org

X-Forwarded-Proto 一个事实标准，用来标识HTTP原始协议，因为反向代理或者负载均衡器和web服务器可能使用http,但是请求到反向代理使用的是https
                  X-Forwarded-Proto: https

Front-End-Https 微软应用程序和负载均衡器使用的非标准header字段 
                  Front-End-Https: on

X-Http-Method-Override 请求web应用时，使用header字段中给定的方法（通常是put或者delete）覆盖请求中指定的方法（通常是post）,如果用户代理或者防火墙不支持直接使用put或者delete方法发送请求时，可以使用这个字段
                  X-HTTP-Method-Override: DELETE

X-ATT-DeviceId 允许更简单的解析用户代理在AT&T设备上的MakeModel/Firmware
                  X-Att-Deviceid: GT-P7320/P7320XXLPG

X-Wap-Profile 设置描述当前连接设备的详细信息的xml文件在网络中的位置
                  x-wap-profile: http://wap.samsungmobile.com/uaprof/SGH-I777.xml

X-UIDH 服务端深度包检测插入的一个唯一ID标识Verizon Wireless的客户


X-Csrf-Token,X-CSRFToken,X-XSRF-TOKEN 防止跨站请求伪造
                  X-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql

X-Request-ID,X-Correlation-ID 标识客户端和服务端的HTTP请求
                  X-Request-ID: f058ebd6-02f7-4d3f-942e-904344e8cde5









////常用标准响应头字段
Access-Control-Allow-Origin 指定哪些站点可以参与跨站资源共享
                  Access-Control-Allow-Origin: *

Accept-Patch 指定服务器支持的补丁文档格式，适用于http的patch方法
                  Accept-Patch: text/example;charset=utf-8

Accept-Ranges 服务器通过byte serving支持的部分内容范围类型
                  Accept-Ranges: bytes

Age 对象在代理缓存中暂存的秒数
                  Age: 12

Allow 设置特定资源的有效行为，适用方法不被允许的http 405错误
                  Allow: GET, HEAD

Alt-Svc 服务器使用"Alt-Svc"（Alternative Servicesde的缩写）头标识资源可以通过不同的网络位置或者不同的网络协议获取
                  Alt-Svc: h2="http2.example.com:443"; ma=7200

Cache-Control 告诉服务端到客户端所有的缓存机制是否可以缓存这个对象，单位是秒
                  Cache-Control: max-age=3600


Connection 设置当前连接和hop-by-hop协议请求字段列表的控制选项
                  Connection: close

Content-Disposition 告诉客户端弹出一个文件下载框，并且可以指定下载文件名
                  Content-Disposition: attachment; filename="fname.ext"

Content-Encoding 设置数据使用的编码类型
                  Content-Encoding: gzip

Content-Language 为封闭内容设置自然语言或者目标用户语言
                  Content-Language: en

Content-Length 响应体的字节长度
                  Content-Length: 348

Content-Location 设置返回数据的另一个位置
                  Content-Location: /index.htm

Content-MD5 设置基于MD5算法对响应体内容进行Base64二进制编码
                  Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==

Content-Range 标识响应体内容属于完整消息体中的那一部分
                  Content-Range: bytes 21010-47021/47022

Content-Type 设置响应体的MIME类型
                  Content-Type: text/html; charset=utf-8

Date 设置消息发送的日期和时间
                  Date: Tue, 15 Nov 1994 08:12:31 GMT

ETag 特定版本资源的标识符，通常是消息摘要
                  ETag: "737060cd8c284d8af7ad3082f209582d"

Expires 设置响应体的过期时间
                  Expires: Thu, 01 Dec 1994 16:00:00 GMT

Last-Modified 设置请求对象最后一次的修改日期
                  Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT

Link 设置与其他资源的类型关系
                  Link: </feed>; rel="alternate"

Location 在重定向中或者创建新资源时使用
                  Location: http://www.w3.org/pub/WWW/People.html

P3P 以P3P:CP="your_compact_policy"的格式设置支持P3P(Platform for Privacy Preferences Project)策略，大部分浏览器没有完全支持P3P策略，许多站点设置假的策略内容欺骗支持P3P策略的浏览器以获取第三方cookie的授权
                  P3P: CP="This is not a P3P policy! See http://www.google.com/support/accounts/bin/answer.py?hl=en&answer=151657 for more info."

Pragma 设置特殊实现字段，可能会对请求响应链有多种影响
                  Pragma: no-cache

Proxy-Authenticate 设置访问代理的请求权限
                  Proxy-Authenticate: Basic

Public-Key-Pins 设置站点的授权TLS证书
              Public-Key-Pins: max-age=2592000; pin-sha256="E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=";

Refresh "重定向或者新资源创建时使用，在页面的头部有个扩展可以实现相似的功能，并且大部分浏览器都支持
<meta http-equiv="refresh" content="5; url=http://example.com/">
                  Refresh: 5; url=http://www.w3.org/pub/WWW/People.html

Retry-After 如果实体暂时不可用，可以设置这个值让客户端重试，可以使用时间段（单位是秒）或者HTTP时间
                  Example 1: Retry-After: 120
                  Example 2: Retry-After: Fri, 07 Nov 2014 23:59:59 GMT

Server 服务器名称
                  Server: Apache/2.4.1 (Unix)

Set-Cookie 设置HTTP Cookie
                  Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1

Status 设置HTTP响应状态
                  Status: 200 OK

Strict-Transport-Security 一种HSTS策略通知HTTP客户端缓存HTTPS策略多长时间以及是否应用到子域
                  Strict-Transport-Security: max-age=16070400; includeSubDomains

Trailer 标识给定的header字段将展示在后续的chunked编码的消息中
                  Trailer: Max-Forwards

Transfer-Encoding 设置传输实体的编码格式，目前支持的格式： chunked, compress, deflate, gzip, identity
                  Transfer-Encoding: chunked

TSV Tracking Status Value，在响应中设置给DNT(do-not-track),可能的取值
　　　"!" — under construction
　　　"?" — dynamic
　　　"G" — gateway to multiple parties
　　　"N" — not tracking
　　　"T" — tracking
　　　"C" — tracking with consent
　　　"P" — tracking only if consented
　　　"D" — disregarding DNT
　　　"U" — updated

      TSV: ?

Upgrade 请求客户端升级协议
                  Upgrade: HTTP/2.0, HTTPS/1.3, IRC/6.9, RTA/x11, websocket

Vary 通知下级代理如何匹配未来的请求头已让其决定缓存的响应是否可用而不是重新从源主机请求新的
                  Example 1: Vary: *
                  Example 2: Vary: Accept-Language

Via 通知客户端代理，通过其要发送什么响应
                  Via: 1.0 fred, 1.1 example.com (Apache/1.1)

Warning 实体可能会发生的问题的通用警告
                  Warning: 199 Miscellaneous warning

WWW-Authenticate 标识访问请求实体的身份验证方案
                  WWW-Authenticate: Basic

X-Frame-Options 点击劫持保护：
            　　　deny frame中不渲染
            　　　sameorigin 如果源不匹配不渲染
            　　　allow-from 允许指定位置访问
            　　　allowall 不标准，允许任意位置访问

                  X-Frame-Options: deny

///常用非标准响应头字段
X-XSS-Protection 过滤跨站脚本
                  X-XSS-Protection: 1; mode=block

Content-Security-Policy, X-Content-Security-Policy,X-WebKit-CSP 定义内容安全策略
                  X-WebKit-CSP: default-src 'self'

X-Content-Type-Options 唯一的取值是"",阻止IE在响应中嗅探定义的内容格式以外的其他MIME格式
                  X-Content-Type-Options: nosniff

X-Powered-By 指定支持web应用的技术
                  X-Powered-By: PHP/5.4.0

X-UA-Compatible 推荐首选的渲染引擎来展示内容，通常向后兼容，也用于激活IE中内嵌chrome框架插件
                  <meta http-equiv="X-UA-Compatible" content="chrome=1" />
                  X-UA-Compatible: IE=EmulateIE7
                  X-UA-Compatible: IE=edge
                  X-UA-Compatible: Chrome=1

X-Content-Duration 提供音视频的持续时间，单位是秒，只有Gecko内核浏览器支持
                  X-Content-Duration: 42.666

Upgrade-Insecure-Requests 标识服务器是否可以处理HTTPS协议
                  Upgrade-Insecure-Requests: 1

X-Request-ID,X-Correlation-ID 标识一个客户端和服务端的请求
                  X-Request-ID: f058ebd6-02f7-4d3f-942e-904344e8cde5