1.git init 创建仓库
2.git add <file>  从工作区添加文件到仓库暂存区
3.git commit -m  "说明"  从暂存区提交文件到仓库
4.git status  告诉我们时刻掌握仓库当前的状态，并告诉我们修改了什么
5.git diff <file> 告诉我们文件修改了哪些地方
6.git log  看提交的版本
7.git reset --hard  HEAD^（commit id）  回退到上一个版本，如果是上100个版本太多^可以用HEAD~100代替；也可以通过commit id 跳到对应版本
8.git reflog  可以记录你的每一次命令 ；可以找到各个版本的commit id
9.git diff HEAD -- readme.txt(工作区文件)    可以查看工作区和版本库里面最新版本的区别


10.git checkout -- readme.txt  意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：
	一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
	一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
	也就是让这个文件回到最近一次git commit或git add时的状态。	
11.git reset HEAD <file>  暂存区的修改撤销掉（unstage），重新放回工作区  

场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。
场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。
场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。

12.一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了，这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：
现在你有两个选择：
一是确实要从版本库中删除该文件，那就用命令git rm <file>删掉，并且git commit；
二是是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： git checkout -- <file>


【工作区（Working Directory）:在电脑里能看到的目录
版本库（Repository）:工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。

Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。

第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；

第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。

因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。

一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：
$ git status
On branch master
nothing to commit, working tree clean】


//创建远程仓库  && 本地仓库推送至远程仓库
13.建立ssh加密  创建ssh公钥和密钥
$ ssh-keygen -t rsa -C "youremail@example.com"  
用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。
然后在GitHub上创建ssh密钥，将公钥信息填上去。

【为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。
当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。

最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。

如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。】


14.在gitHub 建立一个仓库，eg.名字为Fire-TONG/WebText  
把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。
关联： git remote add origin https://github.com/Fire-TONG/WebText.git
推送本地仓库：git push -u origin master
【由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。】
I.如果已经存在关联链接 可以先git remote rm origin 删除，再关联新的。
II.只要本地作了提交，就可以通过命令：$ git push origin master
把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！

15.将远程URL在SSH与HTTPS切换
I.打开Git Bash;II.将当前工作目录更改为本地项目;III.$ git remote -v 列出现有的遥控器
IV.git remote set-url命令有两个参数：
		如果您要更新以使用HTTPS，则您的网址可能如下所示：https://github.com/USERNAME/REPOSITORY.git
		如果您要更新以使用SSH，则您的网址可能如下所示：git@github.com:USERNAME/REPOSITORY.git
eg.git remote set-url origin git@github:USERNAME/OTHERREPOSITROY.git     //转ssh
git remote set-url origin  https://github.com/USERNAME/REPOSITORY.git   //转https




//从远程库克隆
假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。
要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。
16.$ git clone git@github.com:Linjston/gitskills.git
 就会生成一个gitskills本地目录，当然修改完也可以将新的推送到远程库gitskills


//分支管理
在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。

I.一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点;   。->。->。<-master <-HEAD
            
II.当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上
      。->。->。<-master 
              <-dev <-HEAD

III.从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变
 。->。->。 <-master （指向第3个提交）
         ->。  <-dev <-HEAD
         （当有第4个提交时，提交到HEAD指向的分支，也就是dev分支，dev指针往前移动一步，而master指针不变）
 【HEAD指向的分支，才是提交的分支】

IV.在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并
。->。->。->。<-master <-HEAD
           <-dev 
 【合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支】

17.创建dev分支，然后切换到dev分支：
$ git checkout -b dev           
//如果分支存在则只切换分支，若不存在则创建并切换到dev分支
//$ git switch -c <name>  //作用同上


git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：
$ git branch dev              //创建名为dev的分支
$ git checkout dev 			  //切换到dev分支  $ git switch  <name> 也可以切换分支 


//git branch命令
$ git branch           //列出本地已经存在的分支
* dev
  master

$git branch -d dev    //删除dev分支
$git branch -r       //查看远程版本库分支列表


18.合并分支
I.dev分支的工作完成，我们就可以切换回master分支：git checkout master ;
切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变.

  。->。->。 <-master <-HEAD
         ->。  <-dev (提交在dev分支上，master中的readme.txt不变)

II.git merge命令用于合并指定分支到当前分支。
$ git merge dev                //将dev分支合并到master分支
Updating d46f35e..b17d20e
Fast-forward
 readme.txt | 1 +
 1 file changed, 1 insertion(+)  
合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。
Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。

III.合并完成后，就可以放心地删除dev分支了
$ git branch -d dev
Deleted branch dev (was b17d20e).

因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。




19.合并冲突
当2个分支合并发生冲突时，文本会用以下方式提醒你，你需要手动合并，将你不要的部分删除，然后再提交。

<<<<<<< HEAD
。。。。。 (master分支原来的内容)
=======
。。。。。 （dev分支的内容）
>>>>>>> dev


git log --graph命令可以看到分支合并图：
git log --graph --pretty=oneline --abbrev-commit

19.--no-ff  
通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。
如果强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。

合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。
eg.$ git merge --no-ff -m "merge with no-ff" dev 


20.Bug分支
master分支中出现bug,需要立马建立一个修复bug的分支，然后master分支合并这个修复bug分支
但是现在从master分支出来的dev分支还在工作，没法立马提交：
解决问题：
I.
Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作
先将dev分支储藏起来   $ git stash
使用$git status 查看工作区，就是干净的

II.
然后切换到master分支->创建bug分支,切换到bug分支->修复bug提交->切换到master分支合并bug分支->删除bug分支

III.
解决bug后，需要继续回到dev分支继续干活。

 切换到dev分支-> 
              git stash list命令看看：
              $ git stash list
              stash@{0}: WIP on dev: f52c633 add merge  
              工作现场还在，Git把stash内容存在某个地方了
                                        ->但是需要恢复一下，有两个办法：
                                          *是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用
                                               git stash drop来删除；
                                          *另一种方式是用git stash pop，恢复的同时把stash内容也删了


【可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：
$ git stash apply stash@{0} 】              


IV.
在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。
同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个提交所做的修改“复制”到dev分支。
注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来。
cherry-pick命令，让我们能复制一个特定的提交到当前分支:git cherry-pick <commit>
eg.$git checkout dev       //切换到dev分支
$ git cherry-pick 4c805e2  //将debug时所做的修改复制过来

【git branch -D <branch> 强行删除未合并的分支】



21.
推送分支，就是把该分支上的所有本地提交推送到远程库。
推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上
$ git push origin master

如果要推送其他分支，比如dev，就改成：
$ git push origin dev


多人协作时，大家都会往master和dev分支上推送各自的修改。
当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin，默认情况下，你的小伙伴只能看到本地的master分支。
现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：
 $ git checkout -b dev origin/dev

 【你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：
 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：
 $ git pull

如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：
$ git branch --set-upstream-to=origin/dev dev
Branch 'dev' set up to track remote branch 'dev' from 'origin'.

再pull：
这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：
】


22.Rebash
Git用(HEAD -> master)和(origin/master)标识出当前分支的HEAD和远程origin的位置

功能1: 合并commit
命令格式
git rebase -i [startpoint] [endpoint] 合并的范围是前开后闭
eg：合并最近三条commit
git rebase -i HEAD~3 (合并了 head^2 head^ head)
进入编辑界面：
1.根据需求按指令编辑commit

pick：保留该commit（缩写:p）
reword：保留该commit，但我需要修改该commit的注释（缩写:r）
edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）
squash：将该commit和前一个commit合并（缩写:s）
fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）
exec：执行shell命令（缩写:x）
drop：我要丢弃该commit（缩写:d）

push时可能失败  加上--force参数 强制push
2.编辑注释


功能2:复制某一段commit
git rebase [startpoint] [endpoint] --onto [branchName]
eg：git rebase HEAD~3 HEAD~1 --onto master 将当前分支的 head^2 head^ 复制到master分支上



//标签管理
发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。

Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针.
tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。

23.创建标签
/创建标签
git tag <name>就可以打一个新标签：
eg.
$ git tag v1.0

默认标签是打在最新提交的commit上的。
选择其他commit 作为标签：
比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：
$git tag <name> <commitId>
eg.
$ git tag v0.9 f52c633

用-a指定标签名，-m指定说明文字  -a <tagname>
eg.
$ git tag -a v0.1 -m "version 0.1 released" 1094adb


/查看标签
git tag查看所有标签：
eg.
$ git tag
v1.0

标签不是按时间顺序列出，而是按字母排序的。可以用
git show <tagname>查看标签信息:
eg.
$git show v1.0
commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)
Author: Michael Liao <askxuefeng@gmail.com>
Date:   Fri May 18 21:56:54 2018 +0800
    add merge



/删除标签
删除本地标签：git tag -d  <tagName>
eg.
$ git tag -d v0.1


如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：
$ git tag -d v0.9
然后，从远程删除。删除命令也是push: git push origin :refs/tags/<tagname>
$ git push origin :refs/tags/v0.9



/推送标签
创建的标签都只存储在本地，不会自动推送到远程。
如果要推送某个标签到远程，使用命令:git push origin <tagname>:
eg.
$ git push origin v1.0

一次性推送全部尚未推送到远程的本地标签:
$ git push origin --tags


24.配置别名
$ git config --global alias. 别名 原命令
eg.
$ git config --global alias.st status
$ git config --global alias.co checkout
$ git config --global alias.ci commit
$ git config --global alias.br branch

--global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用
配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。
每个仓库的Git配置文件都放在.git/config文件中：

也可以配置操作别名
eg.
$ git config --global alias.unstage 'reset HEAD'
代替 
$git reset HEAD  <file>
即
$git  unstage  <file>


